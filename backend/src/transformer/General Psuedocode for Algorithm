General Psuedocode for Algorithm

let template = string
let assignment = string

template = deserializeGraph(template)
assignment = deserializeGraph(assignment)

---

deserializeGraph(graphData: string) {
    let parsed = parseJSON(graphData);
    
    parsed.vertices.forEach((vertex: string) => {
        let newVertex = parseJSON(vertex)
        if newVertex.children.length > 0 {
            // deserialize each child recursively
        }
    })

    // each new vertex is accumulated into a variable named vertices
    let vertices = ...

    // edges are deserialized very similarly
    // it does require a list of vertices because source and target
    // are the index in the vertex array
    let edges = ...

    // next I add a "attributes" variable to vertices
    // instead of having attributes be a separate vertex,
    // they are in a array in the entity
    // this also prevented an issue where items with duplicate labels weren't handled
    // e.x. two entities have a attribute "id"
    // this technique comes from the second paper
    // this would count as merging lower level bits
    // into higher level objects
    vertices.map(v => {
        if v is not attribute return

        let edgesWithThisVertex = ...
        edgesWithThisVertex.forEach(edge => {
            const otherVertex = ...
            if otherVertex is not entity or relationship {
                // if a attribute is not connected to
                // entity or relation then the input is bad
                return;
            }
            otherVertex.attributes.push(v)
        })
    })

    // remove all attributes
    vertices = vertices.filter(v => v is not Attribute)

    // edges are then recreated because indicies in array
    // will have changed if the filter removed anything

    return {
        vertices, edges
    }
}

---

// returns the index of the vertex which has the same label in both
// -1 if not found
findLabelInAssignment()

recursiveGrading(assignment, template, vertex, runningScore) {
    assignmentVertex = findLabelInAssignment(assignment, template, vertex)

    if no assignmentVertex {
        take penalty from runningScore for missing an entire vertex
    }


    // it is possible to remove points for extra attributes
    // but I have not added it yet
    // e.g. student supplies too many
    vertex.attributes.forEach(attribute => {
        // match based on shared label
        let matchingAssignmentAttribute = ...
        
        if no matchingAssignmentAttribute deduct all points

        check each aspect of the attribute, deducting
        the proper category of points if invalid
    });

    // get the edges that have this vertex in the template
    const edgesWithThisVertex = ...

    // go through each, and grade with that one
    edgesWithThisVertex.forEach(edge => {
        let otherVertex = ...
        runningScore = recursiveGrading(assignment, template, otherVertex, runningScore);
    })
    // in the case of loops, I do have a Set object which
    // tracks previously visited vertices
    // an early return occurs on re-visiting

    return runningScore
}

grade(assignment, template) {
    // it is assumed assignment and template are
    // already deserialized

    // go through template and try to find a matching index
    let rootIndex = 0;
    while rootIndex < template.vertices.length && findLabelInAssignment(template, assignment, template.vertices[rootIndex]) == -1 {
        rootIndex++;
    }

    if (rootIndex >= template.vertices.length) {
        // a match could not be found
        return 0;
    }

    let maxScore = ...;
    let runningScore = maxScore;

    let runningScore = recursiveGrading(assignment, template, template.vertices[rootIndex], runningScore);
    return runningScore / maxScore;
}